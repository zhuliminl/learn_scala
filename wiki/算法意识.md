### 栈: 堆书模型，最底下的被埋没，关注点在最顶上

> 栈和队列结构都类似于数组，但是在添加和删除元素的时候更为可控

##### 栈的操作

- `push` 入栈`
- `pop` 出栈
- `peek` 返回栈顶元素
- `clear` 清除栈
- `isEmpty` 确定为空
- `size` 返回元素个数

### 队列：先来先服务，排队模型。关注的时间序列

- `enqueue` 在尾部添加
- `dequeue` 移除最前面的那个
- `front` 返回最靠前的那个
- `isEmpty` 确定为空

### 二分查找

> 就是对半猜

### 数组和链表

> 数组的元素在内存中是连着的，而链表中的元素可以储存在内存的任何地方。链表的每个元素都储存了下一个元素的地址，从而使一系列随机的内存地址串在一起。你可以**把链表想象成一个夺宝游戏**，每一个关卡都指引你下一个关卡的位置

> 链表的优势在于插入元素方便

> 对于链表，当你需要同时读取所有的元素的时候，效率会很高。因为你可以在读取第一个元素时，根据其中的地址**再去读取二个元素**，以此类推。但是如果你需要跳跃，链表的效率就会很低

> 对于数组，当你需要随机地读取元素的时候，效率会很高。因为我们可以迅速找到数组的任何元素，但是插入和删除效率不会很高

> 总之：链表读取慢，但是插入和删除都比数组快

#### 集合:【键，键】我们感兴趣的是每个值本身，并把它当做主要元素

> 集合的特点是一组**无序**的且**唯一**的项组合

#### 集合的操作：并集、交集、差集、子集

#### 字典：【键，值】也被称之为映射 -- `Map`

##### `Map` 和 `Object` 的区别

> 第一个区别在于： `Object` 只能用字符串当做键，而 `Map` 的键可以是任意的类型, 所以 `Map` 是一种更完善的Hash结构实现

#### 散列表（散列映射、映射、字典、关联数组）

> 类比网址对应 IP 模型，网页缓存也是用到散列表模型

##### 散列函数

##### 解决冲突

> 如果两个键映射到了同一个位置，就在这个位置储存一个**链表**

### 排序方法

- 冒泡排序 -- 不断比较，交换移动
- 选择排序 -- 找到最小值，并排列到第一位。然后重复
- 快速排序 -- 找到最小值，并排列到第一位。然后重复

